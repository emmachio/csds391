Exercise #3:
This can be found in the DFS function of the code. It is within the DFS function that I implemented the repeated state checking for DFS, where it checks if the state has been visited before traversing down the state.

Exercise #4:
This can be found in the effectiveBF function of the code. It iteratively calculates a value of b such that the sum of (1+b^1+b^2...+b^d) is equal to N+1 where d is the depth and N is the search cost. It does this by using the bisection method. and either increases or decreases the b it tries according to the equation's result in relation to N+1.

Exercise #5:
Although the table was not explicitly done through code, it used the function compareSolve in order to calculate the search cost, depth, solution length, and effective branching factor for a given problem for each of the three algorithms.